---
# Deployment for Audio Transcription Worker
apiVersion: apps/v1
kind: Deployment
metadata:
  name: transcription-bridge-deployment
  labels:
    app: transcription-bridge
spec:
  replicas: 1
  selector:
    matchLabels:
      app: transcription-bridge
  template:
    metadata:
      labels:
        app: transcription-bridge
    spec:
      containers:
      - name: transcription-bridge-service-worker
        image: transcription-bridge-service:v1
        imagePullPolicy: IfNotPresent
        env:
          - name: KAFKA_BOOTSTRAP_SERVERS
            value: my-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092
          - name: KAFKA_TOPIC_AUDIO_CHUNKS
            value: audio-chunks
          - name: KAFKA_TOPIC_TRANSCRIPTION_RESULTS
            value: transcription-results
          - name: MINIO_ENDPOINT
            value: minio:9000
          - name: MINIO_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: minio-creds
                key: accessKey
          - name: MINIO_SECRET_KEY
            valueFrom:
              secretKeyRef:
                name: minio-creds
                key: secretKey
          - name: MINIO_BUCKET_NAME
            value: audio-chunks
        ports:
        - containerPort: 8001 # Port for FastAPI to expose chunks
          name: http-bridge
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
# Deployment for YouTube Ingestion Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: youtube-ingestion-deployment
  labels:
    app: youtube-ingestion
spec:
  replicas: 1
  selector:
    matchLabels:
      app: youtube-ingestion
  template:
    metadata:
      labels:
        app: youtube-ingestion
    spec:
      containers:
      - name: youtube-ingestion
        image: youtube-ingestion-service:v1
        imagePullPolicy: IfNotPresent
        env:
          - name: KAFKA_BOOTSTRAP_SERVERS
            value: my-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092
          - name: KAFKA_TOPIC_AUDIO_CHUNKS
            value: audio-chunks
          - name: MINIO_ENDPOINT
            value: minio:9000
          - name: MINIO_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: minio-creds
                key: accessKey
          - name: MINIO_SECRET_KEY
            valueFrom:
              secretKeyRef:
                name: minio-creds
                key: secretKey
          - name: MINIO_BUCKET_NAME
            value: audio-chunks
          - name: CHUNK_DURATION_SECONDS
            value: "60"
          - name: OVERLAP_SECONDS
            value: "16"
        ports:
        - containerPort: 8000
          name: http-api
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
# KafkaTopic for audio chunks
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaTopic
metadata:
  name: audio-chunks
  labels:
    strimzi.io/cluster: my-cluster
spec:
  partitions: 1
  replicas: 1
  config:
    retention.ms: 604800000
---
# KafkaTopic for transcription results
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaTopic
metadata:
  name: transcription-results
  labels:
    strimzi.io/cluster: my-cluster
spec:
  partitions: 1
  replicas: 1
  config:
    retention.ms: 604800000
---
# KafkaTopic for chapter results
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaTopic
metadata:
  name: chapter-results
  labels:
    strimzi.io/cluster: my-cluster
spec:
  partitions: 1
  replicas: 1
  config:
    retention.ms: 604800000
---
# Deployment for Chapter Generation Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chapter-generation-deployment
  labels:
    app: chapter-generation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: chapter-generation
  template:
    metadata:
      labels:
        app: chapter-generation
    spec:
      containers:
      - name: chapter-generation-worker
        image: chapter-generation-service:v1
        imagePullPolicy: IfNotPresent
        env:
          - name: KAFKA_BOOTSTRAP_SERVERS
            value: my-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092
          - name: KAFKA_TOPIC_TRANSCRIPTION_RESULTS
            value: transcription-results
          - name: KAFKA_TOPIC_CHAPTER_RESULTS
            value: chapter-results
          - name: KAFKA_CONSUMER_GROUP_ID
            value: chapter-generation-group
          - name: VIDEO_COMPLETION_TIMEOUT
            value: "8"
          - name: GEMINI_API_KEY
            valueFrom:
              secretKeyRef:
                name: gemini-api-key
                key: apiKey
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
# Kubernetes Secret for MinIO credentials
apiVersion: v1
kind: Secret
metadata:
  name: minio-creds
type: Opaque
data:
  accessKey: xyz123abc-minio-access # base64 encoded minio access key
  secretKey: xyz123abc-minio-secret # base64 encoded minio secret key
---
# Kubernetes Secret for Gemini API Key
apiVersion: v1
kind: Secret
metadata:
  name: gemini-api-key
type: Opaque
data:
  apiKey: abc123xyz-your-key # Replace with your base64 encoded gemini API key
---
# Deployment for Frontend Bridge Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-bridge-deployment
  labels:
    app: frontend-bridge
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend-bridge
  template:
    metadata:
      labels:
        app: frontend-bridge
    spec:
      containers:
      - name: frontend-bridge-service
        image: frontend-bridge:v1
        imagePullPolicy: IfNotPresent
        env:
          - name: KAFKA_BOOTSTRAP_SERVERS
            value: my-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092
          - name: KAFKA_TOPIC_CHAPTER_RESULTS
            value: chapter-results
          - name: KAFKA_CONSUMER_GROUP_ID
            value: frontend-bridge-group
        ports:
        - containerPort: 8765
          name: websocket
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "250m"
---
# Service for Frontend Bridge
apiVersion: v1
kind: Service
metadata:
  name: frontend-bridge-service
spec:
  selector:
    app: frontend-bridge
  ports:
    - protocol: TCP
      port: 8765
      targetPort: 8765
---
# Deployment for Database Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: database-service-deployment
  labels:
    app: database-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: database-service
  template:
    metadata:
      labels:
        app: database-service
    spec:
      containers:
      - name: database-service-worker
        image: database-service:v1
        imagePullPolicy: IfNotPresent
        env:
          - name: DATABASE_URL
            value: postgresql://admin:password@postgres-service:5432/chapterdb # Internal Kubernetes service name for Postgres
        ports:
        - containerPort: 8009
          name: http-db
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        readinessProbe:
          httpGet:
            path: /health
            port: 8009 # The internal port the database-service is is listening on
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 6
---
# Service for Database Service
apiVersion: v1
kind: Service
metadata:
  name: database-service-service
spec:
  selector:
    app: database-service
  ports:
    - protocol: TCP
      port: 8008
      targetPort: 8009
---
# Deployment for PostgreSQL
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-deployment
  labels:
    app: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        env:
          - name: POSTGRES_USER
            value: admin
          - name: POSTGRES_PASSWORD
            value: password
          - name: POSTGRES_DB
            value: chapterdb
        ports:
        - containerPort: 5432
          name: postgres-port
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        readinessProbe:
          exec:
            command: ["pg_isready", "-h", "localhost", "-p", "5432", "-U", "admin", "-d", "chapterdb"]
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 5
          failureThreshold: 6
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pv-claim
---
# Service for PostgreSQL
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP # Only accessible within the cluster
---
# Persistent Volume Claim for PostgreSQL
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi # Request 1GB of storage
